# Nom du fichier : .github/workflows/deploy-addons.yml
# DESCRIPTION : Pipeline pour déployer ou détruire les add-ons Kubernetes.
# La destruction est orchestrée pour garantir un nettoyage complet et sans ressources orphelines :
# 1. Les applications GitOps (quiz, quiz-staging) sont supprimées via Argo CD CLI.
# 2. Les données d'Elasticsearch (PVCs) sont supprimées pour libérer les volumes EBS.
# 3. L'infrastructure Terraform est détruite en dernier.

name: "APPS: Deploy or Destroy Kubernetes Add-ons"

on:
  push:
    branches: [main]
    paths: ['terraform/apps/**', '.github/workflows/deploy-addons.yml']
  pull_request:
    branches: [main]
    paths: ['terraform/apps/**', '.github/workflows/deploy-addons.yml']
  workflow_dispatch:
    inputs:
      action:
        description: 'Action: "apply" (déployer) ou "destroy" (détruire)'
        required: true
        default: 'apply'
        type: choice
        options: [apply, destroy]
      confirm_destroy:
        description: 'Si action=destroy, tapez "destroy-all-addons" pour confirmer.'
        required: false

jobs:
  # ===================================================================
  # JOB 1 : DÉPLOIEMENT OU VALIDATION (LOGIQUE "APPLY")
  # ===================================================================
  deploy-addons:
    name: "Terraform Apply for Add-ons"
    # Ce job ne s'exécute que pour les actions 'apply' ou les 'push' sur main
    if: github.event.inputs.action == 'apply' || github.event_name == 'push'
    runs-on: ["self-hosted", "aws-private-runner"]
    defaults:
      run:
        shell: bash
        working-directory: ./terraform/apps

    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Configure Kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --region us-east-1 --name tws-eks-cluster
          kubectl get nodes -o wide

      - name: Terraform Init
        run: terraform init

      - name: Terraform Apply (for workflow_dispatch)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply'
        run: |
          echo "--- Running Terraform Apply: Step 1 (Core Add-ons) ---"
          terraform plan -no-color -out=plan-step1
          terraform apply -auto-approve -input=false plan-step1
          
          echo "--- Waiting 30 seconds for add-ons to stabilize ---"
          sleep 30
          
          echo "--- Running Terraform Apply: Step 2 (App-of-Apps) ---"
          terraform plan -no-color -out=plan-step2 -var="deploy_app_of_apps=true"
          terraform apply -auto-approve -input=false plan-step2

      - name: Validate Terraform Plan (on push to main)
        if: github.event_name == 'push'
        run: terraform plan -no-color

  # ===================================================================
  # JOB 2 : DESTRUCTION ORCHESTRÉE (LOGIQUE "DESTROY")
  # ===================================================================
  destroy-addons:
    name: "Orchestrated Destroy for Add-ons"
    # Ce job ne s'exécute que pour une action 'destroy' manuelle avec confirmation
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.action == 'destroy' &&
      github.event.inputs.confirm_destroy == 'destroy-all-addons'
    
    # "needs" est placé ici, au niveau du JOB. Il est valide et indique que ce job
    # doit attendre la fin du job "deploy-addons" avant de démarrer.
    needs: deploy-addons 
    
    runs-on: ["self-hosted", "aws-private-runner"]
    defaults:
      run:
        shell: bash
        working-directory: ./terraform/apps

    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Configure Kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --region us-east-1 --name tws-eks-cluster
          kubectl get nodes

      # --- ÉTAPE DE NETTOYAGE APPLICATIF (ARGO CD) ---
      - name: "Pre-Destroy: Clean Argo CD Applications"
        run: |
          echo "--- [START] Graceful cleanup for Argo CD managed applications ---"
          
          echo "Installing Argo CD CLI..."
          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64
          
          echo "Authenticating to Argo CD server..."
          # NOTE : En production, utilisez un token d'automatisation stocké dans un secret manager.
          ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d )
          argocd login localhost:8080 --username admin --password "$ARGO_PASSWORD" --insecure --grpc-web
          
          for app in quiz-prod quiz-staging; do
            if argocd app get $app > /dev/null 2>&1; then
              echo "Deleting Argo CD application '$app' with cascade..."
              argocd app delete $app --cascade=true --yes
              echo "Waiting for application '$app' to be fully deleted..."
              argocd app wait $app --delete --timeout 300 || echo "App '$app' already deleted or timeout reached."
            else
              echo "Argo CD application '$app' not found, skipping."
            fi
          done
          
          echo "--- [END] Argo CD application cleanup finished. ---"

      # --- ÉTAPE DE NETTOYAGE DU STOCKAGE (ELASTICSEARCH) ---
      - name: "Pre-Destroy: Clean Elasticsearch PVCs"
        run: |
          echo "--- [START] Graceful cleanup for Elasticsearch PVCs ---"
          
          if kubectl get ns logging > /dev/null 2>&1; then
            echo "Namespace 'logging' found. Deleting all PersistentVolumeClaims..."
            kubectl delete pvc --all -n logging --wait=true --timeout=5m
            echo "PVCs in 'logging' namespace have been deleted."
          else
            echo "Namespace 'logging' not found, skipping PVC cleanup."
          fi
          
          echo "--- [END] Elasticsearch PVC cleanup finished. ---"

      # --- ÉTAPE FINALE : DESTRUCTION DE L'INFRASTRUCTURE ---
      - name: "Execute Terraform Destroy (DANGEROUS)"
        run: |
          echo "WARNING: All pre-destroy cleanup steps are done. Proceeding with 'terraform destroy'."
          
          terraform init
          
          # La destruction est lancée. Les étapes précédentes étant séquentielles dans le même job,
          # cette étape ne démarre que si les nettoyages ont réussi.
          terraform destroy -auto-approve -var="deploy_app_of_apps=true"
